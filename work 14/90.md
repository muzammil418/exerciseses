# ‚öîÔ∏è The Kingdom of Eldara ‚Äî Full Project Guide

---

## üß† 1. Overview

**Goal:**
Build a console-based adventure game where the player explores regions, battles enemies, earns gold, and saves progress.

You‚Äôll create this game step by step, learning how to organize data and logic using C‚Äôs core tools ‚Äî **structures**, **arrays**, **pointers**, **functions**, and **files**.

---

## üß© 2. Game World Summary

| Concept       | Description                                                              |
| ------------- | ------------------------------------------------------------------------ |
| **Player**    | The hero with name, HP, gold, and attack power.                          |
| **Enemies**   | Monsters in different locations with their own stats.                    |
| **Items**     | Weapons and potions the player can buy or use.                           |
| **Locations** | Places (town, forest, cave, castle) with unique difficulty and monsters. |
| **Game Loop** | Menu that repeats until the player exits.                                |

---

## üèóÔ∏è 3. Structure Design

### 3.1 Player Structure

```
struct Player {
    char name[30];
    int level;
    int hp;
    int attack;
    int gold;
    struct Item inventory[5];
    int itemCount;
};
```

**Explanation:**

* `char name[30]`: Player name stored as a string (array of characters).
* `struct Item inventory[5]`: Array of `Item` structures inside the player ‚Äî shows *composition*.
* `int itemCount`: Tracks how many items are owned.

**Key Concepts:**

* Using an array **inside** a struct.
* Storing multiple attributes of one entity together.

---

### 3.2 Item Structure

```
struct Item {
    char name[20];
    int attackBonus;
    int cost;
};
```

**Explanation:**

* Each item has a name, a bonus to attack, and a price in gold.
* Items will be stored in an **array** for shop and inventory systems.

---

### 3.3 Enemy Structure

```
struct Enemy {
    char name[20];
    int hp;
    int attack;
    int goldReward;
};
```

**Explanation:**

* Represents monsters encountered during exploration.
* The `goldReward` is earned when the enemy is defeated.

---

### 3.4 Location Structure

```
struct Location {
    char name[25];
    int dangerLevel;
    struct Enemy enemies[3];
};
```

**Explanation:**

* Each location has a name, a difficulty level, and a small **array of enemies**.
* You‚Äôll use **arrays of structs containing arrays** ‚Äî perfect for learning multi-level structures.

---

### üìä Structure Diagram

```
+----------------+
|    Player      |
+----------------+
| name[30]       |
| level          |
| hp             |
| attack         |
| gold           |
| inventory[5] --+---> +----------------+
| itemCount      |     |     Item       |
+----------------+     +----------------+
                      | name[20]        |
                      | attackBonus     |
                      | cost            |
                      +----------------+

+----------------+
|   Location     |
+----------------+
| name[25]       |
| dangerLevel    |
| enemies[3] ----+---> +----------------+
                      |     Enemy       |
                      +----------------+
                      | name[20]        |
                      | hp              |
                      | attack          |
                      | goldReward      |
                      +----------------+
```

---

## ‚öôÔ∏è 4. Function Design

| Function Name                                                | Purpose                                | Key Concepts             |
| ------------------------------------------------------------ | -------------------------------------- | ------------------------ |
| `createPlayer()`                                             | Ask for name and initialize stats      | Input, strings           |
| `displayStats()`                                             | Print current player stats             | Structures               |
| `battle(Player *p, Enemy *e)`                                | Handle combat between player and enemy | Pointers, random numbers |
| `shop(Player *p)`                                            | Buy/sell items                         | Arrays, conditionals     |
| `explore(Player *p, struct Location locations[], int count)` | Randomly pick an enemy to fight        | Arrays, random access    |
| `saveGame(Player *p)`                                        | Write player data to file              | File I/O, pointers       |
| `loadGame(Player *p)`                                        | Read player data from file             | File I/O, pointers       |
| `mainMenu()`                                                 | Control program loop                   | Function calls, loops    |

**Pointer Use Example:**
When a function needs to modify the player‚Äôs data (like reducing HP), it should receive a **pointer**:

```c
void battle(struct Player *p, struct Enemy *e);
```

This allows the function to change the original player in memory ‚Äî not a copy.

---

## üíæ 5. File I/O Design

### Save Format (save.txt)

```
PlayerName Level HP Attack Gold
ItemCount
Item1Name Item1Bonus Item1Cost
Item2Name Item2Bonus Item2Cost
```

### Steps to Implement:

1. Use `fopen("save.txt", "w")` to open a file for writing.
2. Write player data with `fprintf()`.
3. Close file using `fclose()`.

To load:

1. Use `fopen("save.txt", "r")`.
2. Read back data using `fscanf()`.
3. Fill player structure fields.

**Important library functions:**

| Function                   | Purpose                                         |
| -------------------------- | ----------------------------------------------- |
| `fopen(filename, mode)`    | Open file in read (`"r"`) or write (`"w"`) mode |
| `fprintf(file, format, ‚Ä¶)` | Write text to a file                            |
| `fscanf(file, format, ‚Ä¶)`  | Read formatted data                             |
| `fclose(file)`             | Close file                                      |

---

## üßÆ 6. Arrays and Pointers in Practice

### Arrays

Used to hold multiple similar elements:

* `struct Enemy enemies[3];` ‚Üí multiple monsters in a region.
* `struct Item shopItems[4];` ‚Üí items in the store.
* `struct Location locations[5];` ‚Üí the world map.

### Pointers

Used to **modify** structures in functions or access elements in arrays:

* `Player *p` allows functions to update player stats.
* `Enemy *e` can be a pointer to one element of an enemy array.

### Example Concept

When you pass `battle(&player, &locations[0].enemies[1]);`,
you‚Äôre passing *addresses* of structures ‚Äî not copies.
This saves memory and allows real-time updates.

---

## üß≠ 7. How the Game Flows

```
+------------------+
|  Start Program   |
+------------------+
          |
          v
  [Load Game? or New Player]
          |
          v
     +-----------+
     | Main Menu |
     +-----------+
     | Explore   |
     | Visit Town|
     | View Stats|
     | Save Game |
     | Exit      |
          |
          v
   [Perform Action]
          |
          v
    [Loop Back to Menu]
```

Each action calls its own function ‚Äî teaching how functions organize large programs into manageable pieces.

---

## üìò 8. Concept Explanations

### Structures

> A *structure* is a custom data type that groups variables of different types under one name.
> Used to represent real-world entities like a player or enemy.

Syntax:

```c
struct Player {
    char name[30];
    int hp;
    int gold;
};
```

### Arrays

> Arrays store multiple elements of the same type together.
> You can loop through them to perform operations.

Example:

```c
struct Enemy enemies[3];
```

### Pointers

> Pointers store **addresses** of variables.
> They allow functions to change the original data.

Example:

```c
void heal(struct Player *p) {
    p->hp += 10;   // modifies original player's HP
}
```

### Functions

> Functions divide a large program into smaller, reusable parts.
> Each function should do one specific job (e.g., fight, save, shop).

### File I/O

> Files let the program store data permanently.
> You‚Äôll use text files to save and reload the player‚Äôs state.

Example:

```c
FILE *fp = fopen("save.txt", "w");
fprintf(fp, "%s %d", p->name, p->hp);
fclose(fp);
```

---

## üîç 9. Concept Relationships Diagram

```
          +-------------+
          |   main()    |
          +-------------+
                |
   +-----------------------------+
   |           Calls             |
   v                             v
[explore()]                 [shop()]
   |                             |
   v                             v
[battle()]                [buyItem()]
   |                             |
   v                             v
[saveGame()] <--- uses ---> [loadGame()]
                (File I/O)

All functions operate on:
     ‚Üì
   struct Player (with pointers)
     ‚Üì
   struct Item[], struct Enemy[]
     ‚Üì
   arrays and file storage
```

---

## üóìÔ∏è 10. Suggested Daily Breakdown

| Day   | Focus               | Tasks                                                                  |
| ----- | ------------------- | ---------------------------------------------------------------------- |
| **1** | Structures & arrays | Define `Player`, `Enemy`, `Item`, `Location` structs. Initialize data. |
| **2** | Menu system         | Implement main loop and player creation.                               |
| **3** | Combat              | Write `battle()` function with random results.                         |
| **4** | Shop                | Add `shop()` and item purchase logic.                                  |
| **5** | Exploration         | Use arrays of locations and enemies; integrate combat.                 |
| **6** | Save/Load           | Implement `saveGame()` and `loadGame()`.                               |
| **7** | Review              | Add polish, test all features, and experiment.                         |

---

## üß≠ 11. End Goals

By the end of this project, the student will have:

* Written **a structured C program** with 200‚Äì400 lines of meaningful logic.
* Practiced **arrays, pointers, and structures** together.
* Used **file I/O** to make the game persistent.
* Learned **modular design** through multiple functions.

